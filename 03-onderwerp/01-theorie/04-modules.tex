\chapter{Modules}

Modules zijn een soort packaging formaat voor puppet manifests, net zoals Perl CPAN heeft, Python eggs heeft en een besturingssyteem software-pakketten kan installeren om zijn functionaliteit uit te breiden. Dit houd in dat men de manifests, templates, files en alle benodigdheden voor een bepaald project/functie in \'{e}\'{e}n map steekt, en het vervolgens als 'addon' kan gebruiken op andere systemen die dezelfde functionaliteit nodig hebben.\\\\
Door deze functionaliteit is het mogelijk om bijvoorbeeld een mysql module te ontwikkelen waarmee je alles van een mysql server/client kan beheren, gaande van het aanmaken, wijzigen en verwijderen van databases, gebruikers en rechten tot de software-pakketten en configuraties van mysql. Vervolgens kan men deze module op een andere computer in de juiste map zetten en ze hergebruiken. Door deze functionaliteit kan men zeer snel en efficient veel voorkomende taken automatiseren, en kan men zich dus focussen op belangrijkere taken.\\\\
Uiteraard zijn er voor de correcte werking en interoperability op verschillende systemen specificaties nodig die als richtlijnen fungeren om modules te bouwen. Zo is een correcte mappenstructuur een must, en als je die niet volgt zal je module dus ook niet werken. Allereerst heb je de root map van de module, deze wordt onder de 'puppet/modules' map geplaatst. Daarna heb je onderverdelingen voor manifests, templates en files. Last but not least heb je in de root map nog een README bestand staan, waarin wordt aangegeven wie deze module gemaakt heeft, hoe deze gebruikt dient te worden en onder welke licentie deze valt.\\\\
\begin{samepage}
Even een overzicht:\\\\
\$MODULE\_PATH/
	\begin{itemize}
	\item mysql/
		\begin{itemize}
		\item files/
		\item manifests/
		\item templates/
		\item README
		\end{itemize}
	\end{itemize}
\end{samepage}

Een puppet module is een verzameling van resource types, classes, bestanden, defines en templates. Je kan bijvoorbeeld een module maken die een Ruby on Rails applicatie opzet, een Apache webserver of MySQL database. Modules zijn gemaakt om simpel te kunnen distribueren

Modules are easily re-distributable. For example, this will enable you to have the default site configuration under /etc/puppet, with modules shipped by Puppet proper in /usr/share/puppet/. You could also have other directories containing a happy mix-and-match of version control checkouts in various states of development and production readiness.

Modules are available in Puppet version 0.22.2 and later.
Configuration

There are two configuration settings that pertain to modules:

    The search path for modules is defined with the modulepath setting in the [puppetmasterd] (pre-2.6) or [master] (post-2.6) section of the puppet master's config file, and it should be a colon-separated list of directories:

    [puppetmasterd]
    ...
    modulepath = /var/lib/puppet/modules:/data/puppet/modules

    the search path can be added to at runtime by setting the puppetlib environment variable, which must also be a colon-separated list of directories.

    access control settings for the fileserver module [modules] are set in fileserver.conf, as described later in this page. the path configuration for that module is always ignored, and specifying a path will produce a warning.

sources of modules

to accommodate different locations in the file system for the different use cases, there is a configuration variable modulepath which is a list of directories to scan in turn.

a reasonable default could be configured as /etc/puppet/modules:/usr/share/puppet:/var/lib/modules. alternatively, the /etc/puppet directory could be established as a special anonymous module which is always searched first to retain backwards compatibility to today's layout.

For some environments it might be worthwhile to consider extending the modulepath configuration item to contain branches checked out directly from version control, for example:

svn:file:///Volumes/svn/repos/management/master/puppet.testing/trunk

Naming

Module names should be restricted to lowercase alphanumeric characters and underscores, and should begin with a lowercase letter; that is, they should match the expression [a-z][a-z0-9\_]*. Note that these are the same restrictions that apply to class names, with the added restriction that module names cannot contain the namespace separator (::) as modules cannot be nested.

Although some names that violate these restrictions currently work, using them is not recommended.

The module name site is reserved for local use and should not be used in modules meant for distribution.
Internal Organisation

A Puppet module contains manifests, distributable files, plugins and templates arranged in a specific directory structure:

%MODULE\_PATH/
%+--downcased\_module\_name/
   %+--files/
   %+--manifests/
   %|  +--init.pp
   %|  +--foo.pp
   %+--lib/
   %|  +--puppet/
   %|  |  +--parser/
   %|  |  |  +--functions/
   %|  |  +--provider/
   %|  |  +--type/
   %|  +--facter/
   %+--templates/
   %+--tests
   %|  +--init.pp
   %|  +--foo.pp
   %+--README

NOTE: In Puppet versions prior to 0.25.0 the lib directory was named plugins. Other directory names are unchanged.

Each module must contain a init.pp manifest file at the specified location. This manifest file can contain all the classes associated with this module or additional .pp files can be added directly under the manifests folder. If adding additional .pp files, naming them after the class they define will allow auto lookup magic (explained further below in Module Lookup).

One of the things to be accomplished with modules is code sharing. A module by nature should be self-contained: one should be able to get a module from somewhere and drop it into your module path and have it work.

There are cases, however, where the module depends on generic things that most people will already have defines or classes for in their regular manifests. Instead of adding these into the manifests of your module, add them to the depends folder (which is basically only documenting, it doesn't change how your module works) and mention these in your README, so people can at least see exactly what your module expects from these generic dependencies, and possibly integrate them into their own regular manifests.

(See Plugins In Modules for info on how to put custom types and facts into modules in the plugins/ subdir)
Example

As an example, consider a autofs module that installs a fixed auto.homes map and generates the auto.master from a template. Its init.pp could look something like:
%
\begin{code}
\begin{lstlisting}
class autofs {
  package { autofs: ensure => latest }
  service { autofs: ensure => running }
  file { '/etc/auto.homes':
    source => 'puppet://\$servername/modules/autofs/auto.homes'
  }
  file { '/etc/auto.master':
    content => template('autofs/auto.master.erb')
  }
}
\end{lstlisting}
\end{code}
%
and have these files in the file system:

MODULE\_PATH/
  autofs/
    manifests/
      init.pp
    files/
      auto.homes
    templates/
      auto.master.erb

Notice that the file source path includes a modules/ component. In Puppet version 0.25 and later, you must include this component in source paths in order to serve files from modules. Puppet 0.25 will still accept source paths without it, but it will warn you with a deprecation notice about 'Files found in modules without specifying 'modules' in file path'. In versions 0.24 and earlier, source paths should not include the modules/ component.

Note also that you can still access files in modules when using puppet instead of puppetd; just leave off the server name and puppetd will fill in the server for you (using its configuration server as its file server) and puppet will use its module path:
%
\begin{code}
\begin{lstlisting}
file { '/etc/auto.homes':
    source => 'puppet:///modules/autofs/auto.homes'
}
\end{lstlisting}
\end{code}
%
Module Lookup

Since modules contain different subdirectories for different types of files, a little behind-the-scenes magic makes sure that the right file is accessed in the right context. All module searches are done within the modulepath, a colon-separated list of directories. In most cases, searching files in modules amounts to inserting one of manifest, files, or templates after the first component into a path, i.e. paths can be thought of as downcased\_module\_name/part\_path where part\_path is a path relative to one of the subdirectories of the module module\_name.

For file references on the fileserver, a similar lookup is used so that a reference to puppet://\$servername/modules/autofs/auto.homes resolves to the file autofs/files/auto.homes in the module's path. (Note that this behavior will break if you have declared an explicit [autofs] mount in your fileserver.conf, so take care to avoid name collisions when assigning custom fileserver mount points outside of modules.)

You can apply some access controls to files in your modules by creating a [modules] file mount, which should be specified without a path statement, in the fileserver.conf configuration file:
%
\begin{code}
\begin{lstlisting}
[modules]
allow *.domain.com
deny *.wireless.domain.com
\end{lstlisting}
\end{code}
%
Unfortunately, you cannot apply more granular access controls, for example at the per module level as yet.

To make a module usable with both the command line client and a puppetmaster, you can use a URL of the form puppet:///path, i.e. a URL without an explicit server name. Such URL's are treated slightly differently by puppet and puppetd: puppet searches for a serverless URL in the local filesystem, and puppetd retrieves such files from the fileserver on the puppetmaster. This makes it possible to use the same module as part of a site manifest on a puppetmaster and in a standalone puppet script by running puppet --modulepath \{path\} script.pp, without any changes to the module.

Finally, template files are searched in a manner similar to manifests and files: a mention of template('autofs/auto.master.erb') will make the puppetmaster first look for a file in \$templatedir/autofs/auto.master.erb and then autofs/templates/auto.master.erb on the module path. This allows more-generic files to be provided in the templatedir and more-specific files under the module path (see the discussion under Feature 1012 for the history here).
Module Autoloading

Since version 0.23.1, Puppet will attempt to autoload classes and definitions from modules, so you no longer have to explicitly import them; you can just include the class or start using the definition.

The rules Puppet uses to find the appropriate manifest when a module class or definition is declared are pretty easy to understand, and break down like this:
include foo 	

\{modulepath\}/foo/manifests/init.pp

class foo \{ ... \}
include foo::bar 	

\{modulepath\}/foo/manifests/bar.pp

class foo::bar \{ ... \}
foo::params \{ 'example': value => 'meow' \} 	

\{modulepath\}/foo/manifests/params.pp

define foo::params (\$value) \{ ... \}
class \{ 'foo::bar::awesome': \} 	

\{modulepath\}/foo/manifests/bar/awesome.pp

class foo::bar::awesome { ... }

In short, lookup paths within a module's manifest directory are derived by splitting class and definition names on :: separators, then interpreting the first element as the name of the module, the final element as the filename (with a .pp extension appended), and any intermediate elements as subdirectories of the module's manifests directory:

{module name}::{subdirectory}::{...}::{filename (sans extension)}

The one special case is that a one-wordt class or definition name which matches the name of the module will always be found in manifests/init.pp.1

Since lookup of classes and definitions is based on filename, take care to always rename both at the same time.
Generated Module Documentation

If you decide to make your modules available to others (and please do!), then please also make sure you document your module so others can understand and use them. Most importantly, make sure the dependencies on other defines and classes not in your module are clear.

From Puppet version 0.24.7 you can generate automated documentation from resources, classes and modules using the puppetdoc tool. You can find more detail at the Puppet Manifest Documentation page.

\subsection{Voorbeelden}
Hier bekijken we even enkele voorbeelden van echte modules. We maken gebruik van de exacte code die ik in het dagelijkse leven gebruik, maar wel met een hele hoop uitleg ertussen. Deze uitleg kan je herkennen aan de '\#' tekens ervoor (normaal gezien worden deze gebruikt om commentaar aan te duiden, dus een logische keuze). Let er op dat dit hoogst waarschijnlijk niet de beste modules zijn die je kan vinden, deze zijn ook slechts gebouwd met mijn beperkte kennis en zijn bijlange na niet feature-complete. In de toekomst zullen deze verder uitgebreid en verbeterd worden en ondertussen kan u gerust eens gaan kijken op de bovenvermelde website, waar u meer modules zal vinden.

Als eerste voorbeeld een Apache module:
%
\begin{code}
\begin{lstlisting}
Apache
+--manifests
|	+--config.pp
|	+--init.pp
|	+--mod-php.pp
|	+--packages.pp
|	+--passenger.pp
|	+--prefork.pp
|	+--xsendfile.pp
|
+--templates
	+--httpd.conf.erb
\end{lstlisting}
\end{code}
%
Dit is de basis mapstructuur voor deze module. Een aantal van de bestanden in de manifests map zijn niet strict noodzakelijk, maar vormen een mooie uitbreiding op het standaardaanbod aan ingebouwde modules voor Apache.
\begin{code}
\begin{lstlisting}
class apache::packages {
	package { apache:
		ensure => installed,
		name => $operatingsystem ? {
			archlinux => 'apache',
			/Debian|Ubuntu/ => 'apache2',
			/Centos|Fedora/ => 'httpd',
		},
	}

	service { apache_daemon:
		ensure => running,
		enable => true,
		name => $operatingsystem ? {
			/Debian|Ubuntu/ => 'apache2',
			/Centos|Fedora/ => 'httpd',
		},
		require => Package['apache'],
	}

	package { 'apache-dev':
		ensure => installed,
		name => $operatingsystem ? {
			/Debian|Ubuntu/ => 'apache2-threaded-dev',
			/Centos|Fedora/ => 'httpd-devel',
		},
	}
}
\end{lstlisting}
\end{code}
